#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from control_msgs.action import FollowJointTrajectory
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint
from sensor_msgs.msg import JointState
from geometry_msgs.msg import PoseStamped
from std_msgs.msg import UInt8
import math
import time
import json


class UR5eWaypointController(Node):
    def __init__(self):
        super().__init__('ur5e_waypoint_controller')
                    parts = command.split(' ')
                    filename = parts[1]
                    delay = 0.1  # Default delay - much shorter for continuous motion
                    
                    if len(parts) >= 3:
                        try:
                            delay = float(parts[2])
                            if delay < 0:
                                print("❌ Delay must be >= 0")
                                continue
                        except ValueError:
                            print("❌ Invalid delay. Must be a number >= 0")
                            continue
                    
                    waypoint_set = controller.load_waypoint_set(filename)
                    if waypoint_set:
                        controller.execute_waypoint_sequence(waypoint_set, delay)r')
        
        # Action client for joint trajectory control
        self.trajectory_client = ActionClient(
            self,
            FollowJointTrajectory,
            '/scaled_joint_trajectory_controller/follow_joint_trajectory'
        )
        
        # Subscribe to current joint states
        self.joint_subscription = self.create_subscription(
            JointState,
            '/joint_states',
            self.joint_state_callback,
            10
        )
        
        # Subscribe to TCP pose
        self.pose_subscription = self.create_subscription(
            PoseStamped,
            '/tcp_pose_broadcaster/pose',
            self.pose_callback,
            10
        )
        
        # Gripper control publisher
        self.gripper_publisher = self.create_publisher(
            UInt8,
            '/lebai_gripper/cmd/position',
            10
        )
        
        # Subscribe to gripper state
        self.gripper_state_subscription = self.create_subscription(
            UInt8,
            '/lebai_gripper/state/position',
            self.gripper_state_callback,
            10
        )
        
        self.current_joints = None
        self.current_pose = None
        self.current_gripper_position = None
        self.joint_names = [
            'shoulder_pan_joint',
            'shoulder_lift_joint', 
            'elbow_joint',
            'wrist_1_joint',
            'wrist_2_joint',
            'wrist_3_joint'
        ]
        
        print(" UR5e Waypoint Controller initialized")
        
    def joint_state_callback(self, msg):
        """Update current joint states"""
        if len(msg.name) >= 6:
            # Reorder joints to match expected order
            joint_dict = dict(zip(msg.name, msg.position))
            self.current_joints = [joint_dict.get(name, 0.0) for name in self.joint_names]
    
    def pose_callback(self, msg):
        """Update current TCP pose"""
        self.current_pose = msg.pose
    
    def gripper_state_callback(self, msg):
        """Update current gripper state"""
        self.current_gripper_position = msg.data
    
    def wait_for_connections(self, timeout=10.0):
        """Wait for action server and topics to be ready"""
        print(" Waiting for robot connections...")
        
        # Wait for action server
        if not self.trajectory_client.wait_for_server(timeout_sec=timeout):
            print(" Failed to connect to trajectory action server!")
            return False
            
        # Wait for joint states
        start_time = time.time()
        while self.current_joints is None and (time.time() - start_time) < timeout:
            rclpy.spin_once(self, timeout_sec=0.1)
            
        if self.current_joints is None:
            print(" Failed to receive joint states!")
            return False
            
        print(" Robot connections ready!")
        return True
    
    def quaternion_to_euler(self, x, y, z, w):
        """Convert quaternion to Euler angles (roll, pitch, yaw)"""
        # Roll (x-axis rotation)
        sinr_cosp = 2 * (w * x + y * z)
        cosr_cosp = 1 - 2 * (x * x + y * y)
        roll = math.atan2(sinr_cosp, cosr_cosp)
        
        # Pitch (y-axis rotation)
        sinp = 2 * (w * y - z * x)
        if abs(sinp) >= 1:
            pitch = math.copysign(math.pi / 2, sinp)
        else:
            pitch = math.asin(sinp)
        
        # Yaw (z-axis rotation)
        siny_cosp = 2 * (w * z + x * y)
        cosy_cosp = 1 - 2 * (y * y + z * z)
        yaw = math.atan2(siny_cosp, cosy_cosp)
        
        return roll, pitch, yaw

    def get_current_position(self):
        """Get current 6-DOF pose as array [x, y, z, rx, ry, rz]"""
        if self.current_pose is None:
            return None
            
        pos = self.current_pose.position
        ori = self.current_pose.orientation
        
        # Convert quaternion to Euler angles
        roll, pitch, yaw = self.quaternion_to_euler(ori.x, ori.y, ori.z, ori.w)
        
        return [pos.x, pos.y, pos.z, roll, pitch, yaw]
    
    def get_current_gripper_position(self):
        """Get current gripper position"""
        return self.current_gripper_position
    
    def control_gripper(self, position, wait_time=2.0):
        """Control gripper position (0-100)"""
        if not (0 <= position <= 100):
            print(f" Invalid gripper position {position}. Must be 0-100")
            return False
            
        msg = UInt8()
        msg.data = position
        
        print(f" Moving gripper to position {position}")
        self.gripper_publisher.publish(msg)
        
        # Wait for gripper to move
        time.sleep(wait_time)
        
        print(" Gripper movement completed")
        return True
    
    def get_current_joints(self):
        """Get current joint positions"""
        return list(self.current_joints) if self.current_joints else None
    
    def move_to_joint_waypoint(self, joint_positions, duration=5.0, gripper_position=None, wait_time=0.0):
        """Move robot to specified joint positions with optional gripper control and wait"""
        if len(joint_positions) != 6:
            print(" Joint positions must be a list of 6 values!")
            return False
            
        if self.current_joints is None:
            print(" Current joint states not available!")
            return False
        
        # Control gripper before movement if specified
        if gripper_position is not None:
            if not self.control_gripper(gripper_position):
                return False
        
        # Create trajectory goal
        goal_msg = FollowJointTrajectory.Goal()
        goal_msg.trajectory.joint_names = self.joint_names
        
        # Add current position as starting point
        start_point = JointTrajectoryPoint()
        start_point.positions = list(self.current_joints)
        start_point.velocities = [0.0] * 6
        start_point.time_from_start.sec = 0
        start_point.time_from_start.nanosec = 0
        
        # Add target position
        end_point = JointTrajectoryPoint()
        end_point.positions = joint_positions
        end_point.velocities = [0.0] * 6
        end_point.time_from_start.sec = int(duration)
        end_point.time_from_start.nanosec = int((duration % 1) * 1e9)
        
        goal_msg.trajectory.points = [start_point, end_point]
        
        print(f" Moving to joint waypoint: {[round(j, 3) for j in joint_positions]}")
        if gripper_position is not None:
            print(f" With gripper position: {gripper_position}")
        
        # Send goal and wait for acceptance
        future = self.trajectory_client.send_goal_async(goal_msg)
        rclpy.spin_until_future_complete(self, future)
        
        goal_handle = future.result()
        if not goal_handle.accepted:
            print(" Goal rejected!")
            return False
            
        print(" Goal accepted, robot moving...")
        
        # Wait for completion with timeout
        result_future = goal_handle.get_result_async()
        rclpy.spin_until_future_complete(self, result_future)
        
        result = result_future.result().result
        if result.error_code == 0:
            print(" Waypoint reached successfully!")
            
            # Additional wait time after waypoint completion
            if wait_time > 0:
                print(f" Waiting {wait_time}s at waypoint...")
                time.sleep(wait_time)
                
            return True
        else:
            print(f" Motion failed with error code: {result.error_code}")
            return False
    
    def move_to_named_position(self, position_name):
        """Move to predefined named positions"""
        named_positions = {
            'home': [0.0, -1.57, 0.0, -1.57, 0.0, 0.0],
            'ready': [0.0, -1.57, 1.57, -1.57, -1.57, 0.0],
            'observe': [0.0, -2.0, 1.0, -0.57, -1.57, 0.0],
            'pick': [0.0, -1.8, 1.3, -1.0, -1.57, 0.0],
            'place': [1.57, -1.8, 1.3, -1.0, -1.57, 0.0]
        }
        
        if position_name.lower() not in named_positions:
            print(f" Unknown position '{position_name}'. Available: {list(named_positions.keys())}")
            return False
            
        joint_positions = named_positions[position_name.lower()]
        print(f" Moving to '{position_name}' position")
        return self.move_to_joint_waypoint(joint_positions)
    
    def save_current_waypoint(self, name, gripper_position=None, wait_time=0.0):
        """Save current position as a named waypoint with optional gripper position and wait time"""
        if self.current_joints is None:
            print(" No current joint position available!")
            return False
            
        # Use current gripper position if not specified
        if gripper_position is None:
            gripper_position = self.current_gripper_position
            
        waypoint_data = {
            'name': name,
            'joints': list(self.current_joints),  # Required for robot control
            'pose': self.get_current_position(),  # Reference [x, y, z, rx, ry, rz]
            'gripper': gripper_position,
            'wait_time': wait_time
        }
        
        # Save to file
        filename = f"waypoint_{name}.json"
        try:
            with open(filename, 'w') as f:
                json.dump(waypoint_data, f, indent=2)
            print(f" Waypoint '{name}' saved to {filename}")
            print(f"   Joints: {[round(j, 3) for j in self.current_joints]}")
            if waypoint_data['pose']:
                pose = waypoint_data['pose']
                print(f"   Pose: [{pose[0]:.4f}, {pose[1]:.4f}, {pose[2]:.4f}, {pose[3]:.4f}, {pose[4]:.4f}, {pose[5]:.4f}]")
            if waypoint_data['gripper'] is not None:
                print(f"   Gripper: {waypoint_data['gripper']}")
            if waypoint_data['wait_time'] > 0:
                print(f"   Wait time: {waypoint_data['wait_time']}s")
            return True
        except Exception as e:
            print(f" Failed to save waypoint: {e}")
            return False
    
    def load_and_move_to_waypoint(self, name):
        """Load and move to a saved waypoint with gripper control and wait time"""
        filename = f"waypoint_{name}.json"
        try:
            with open(filename, 'r') as f:
                waypoint_data = json.load(f)
                
            print(f" Loading waypoint '{name}' from {filename}")
            joints = waypoint_data['joints']
            gripper_pos = waypoint_data.get('gripper', None)
            wait_time = waypoint_data.get('wait_time', 0.0)
            
            return self.move_to_joint_waypoint(joints, gripper_position=gripper_pos, wait_time=wait_time)
            
        except FileNotFoundError:
            print(f" Waypoint file {filename} not found!")
            return False
        except Exception as e:
            print(f" Failed to load waypoint: {e}")
            return False
    
    def load_waypoint_set(self, filename):
        """Load a set of waypoints from a JSON file"""
        try:
            with open(filename, 'r') as f:
                waypoint_set = json.load(f)
            print(f" Loaded waypoint set from {filename}")
            return waypoint_set
        except FileNotFoundError:
            print(f" Waypoint set file {filename} not found!")
            return None
        except Exception as e:
            print(f" Failed to load waypoint set: {e}")
            return None
    
    def save_waypoint_set(self, waypoints, filename):
        """Save a set of waypoints to a JSON file"""
        try:
            with open(filename, 'w') as f:
                json.dump(waypoints, f, indent=2)
            print(f" Waypoint set saved to {filename}")
            return True
        except Exception as e:
            print(f" Failed to save waypoint set: {e}")
            return False
    
    def execute_waypoint_sequence(self, waypoint_set, delay=0.1):
        """Execute a sequence of waypoints from a waypoint set with guaranteed completion"""
        if not waypoint_set:
            print(" No waypoint set provided!")
            return False
        
        waypoints = waypoint_set.get('waypoints', [])
        set_name = waypoint_set.get('name', 'Unknown')
        
        if not waypoints:
            print(" No waypoints found in set!")
            return False
        
        print(f" Executing waypoint sequence: {set_name}")
        print(f"   Number of waypoints: {len(waypoints)}")
        
        for i, waypoint in enumerate(waypoints, 1):
            name = waypoint.get('name', f'Waypoint_{i}')
            joints = waypoint.get('joints', [])
            gripper_pos = waypoint.get('gripper', None)
            wait_time = waypoint.get('wait_time', 0.0)
            
            # If no joints provided, this waypoint set is pose-only
            if not joints:
                print(f"Waypoint '{name}' missing joint data, skipping...")
                continue
            
            if len(joints) != 6:
                print(f" Invalid joint data for waypoint '{name}', skipping...")
                continue
            
            print(f"   Moving to waypoint {i}/{len(waypoints)}: {name}")
            if gripper_pos is not None:
                print(f"      Gripper position: {gripper_pos}")
            if wait_time > 0:
                print(f"      Wait time: {wait_time}s")
            
            # Move to waypoint with full completion guarantee
            if not self.move_to_joint_waypoint(joints, gripper_position=gripper_pos, wait_time=wait_time):
                print(f" Failed to reach waypoint '{name}', stopping sequence.")
                return False
            
            # Additional delay between waypoints (separate from waypoint wait time)
            if i < len(waypoints) and delay > 0:
                print(f"    Inter-waypoint delay: {delay}s...")
                time.sleep(delay)
        
        print(" Waypoint sequence completed successfully!")
        return True


def main():
    """Main function for interactive waypoint control"""
    rclpy.init()
    
    try:
        controller = UR5eWaypointController()
        
        if not controller.wait_for_connections():
            return
            
        print("\n🎮 UR5e Waypoint Controller Ready!")
        print("Commands:")
        print("  home, ready, observe, pick, place - Move to named positions")
        print("  gripper <position> - Control gripper (0-100: 0=open, 100=closed)")
        print("  save <name> [gripper_pos] [wait_time] - Save waypoint with optional gripper & wait time")
        print("  load <name> - Move to saved waypoint")
        print("  execute <filename.json> [delay] - Execute waypoint sequence (delay between waypoints)")
        print("  create_set <filename.json> - Create new empty waypoint set")
        print("  add_to_set <filename.json> <name> [gripper] [wait_time] - Add current position to set") 
        print("  pos - Show current position and gripper state")
        print("  quit - Exit")
        
        while True:
            try:
                command = input("\n Command: ").strip().lower()
                
                if command == 'quit' or command == 'q':
                    break
                elif command == 'pos':
                    joints = controller.get_current_joints()
                    pose = controller.get_current_position()
                    gripper_pos = controller.get_current_gripper_position()
                    if joints:
                        print(f" Joints: {[round(j, 3) for j in joints]}")
                    if pose:
                        print(f" Pose: [{pose[0]:.4f}, {pose[1]:.4f}, {pose[2]:.4f}, {pose[3]:.4f}, {pose[4]:.4f}, {pose[5]:.4f}]")
                    if gripper_pos is not None:
                        print(f" Gripper: {gripper_pos}")
                elif command in ['home', 'ready', 'observe', 'pick', 'place']:
                    controller.move_to_named_position(command)
                elif command.startswith('gripper '):
                    try:
                        position = int(command.split(' ', 1)[1])
                        controller.control_gripper(position)
                    except (ValueError, IndexError):
                        print(" Usage: gripper <position> (0-100)")
                elif command.startswith('save '):
                    parts = command.split(' ')
                    if len(parts) >= 2:
                        name = parts[1]
                        gripper_pos = None
                        wait_time = 0.0
                        
                        # Parse optional gripper position
                        if len(parts) >= 3:
                            try:
                                gripper_pos = int(parts[2])
                                if not (0 <= gripper_pos <= 100):
                                    print(" Gripper position must be 0-100")
                                    continue
                            except ValueError:
                                print(" Invalid gripper position. Must be a number 0-100")
                                continue
                        
                        # Parse optional wait time
                        if len(parts) >= 4:
                            try:
                                wait_time = float(parts[3])
                                if wait_time < 0:
                                    print(" Wait time must be >= 0")
                                    continue
                            except ValueError:
                                print(" Invalid wait time. Must be a number >= 0")
                                continue
                                
                        controller.save_current_waypoint(name, gripper_pos, wait_time)
                    else:
                        print(" Usage: save <name> [gripper_position] [wait_time]")
                elif command.startswith('load '):
                    name = command.split(' ', 1)[1]
                    controller.load_and_move_to_waypoint(name)
                elif command.startswith('execute '):
                    parts = command.split(' ')
                    filename = parts[1]
                    delay = 0.5  # Default delay
                    
                    if len(parts) >= 3:
                        try:
                            delay = float(parts[2])
                            if delay < 0:
                                print(" Delay must be >= 0")
                                continue
                        except ValueError:
                            print(" Invalid delay. Must be a number >= 0")
                            continue
                    
                    waypoint_set = controller.load_waypoint_set(filename)
                    if waypoint_set:
                        controller.execute_waypoint_sequence(waypoint_set, delay)
                elif command.startswith('create_set '):
                    filename = command.split(' ', 1)[1]
                    empty_set = {
                        'name': filename.replace('.json', ''),
                        'description': 'Waypoint set created by UR5e controller',
                        'waypoints': []
                    }
                    controller.save_waypoint_set(empty_set, filename)
                elif command.startswith('add_to_set '):
                    parts = command.split(' ')
                    if len(parts) < 3:
                        print(" Usage: add_to_set <filename.json> <waypoint_name> [gripper] [wait_time]")
                        continue
                        
                    filename, waypoint_name = parts[1], parts[2]
                    gripper_pos = None
                    wait_time = 0.0
                    
                    # Parse optional gripper position
                    if len(parts) >= 4:
                        try:
                            gripper_pos = int(parts[3])
                            if not (0 <= gripper_pos <= 100):
                                print(" Gripper position must be 0-100")
                                continue
                        except ValueError:
                            print(" Invalid gripper position. Must be a number 0-100")
                            continue
                    
                    # Parse optional wait time
                    if len(parts) >= 5:
                        try:
                            wait_time = float(parts[4])
                            if wait_time < 0:
                                print(" Wait time must be >= 0")
                                continue
                        except ValueError:
                            print(" Invalid wait time. Must be a number >= 0")
                            continue
                    
                    # Load existing set
                    waypoint_set = controller.load_waypoint_set(filename)
                    if waypoint_set and controller.current_joints:
                        # Use current gripper position if not specified
                        if gripper_pos is None:
                            gripper_pos = controller.current_gripper_position
                            
                        # Add current position
                        waypoint_data = {
                            'name': waypoint_name,
                            'joints': list(controller.current_joints),
                            'pose': controller.get_current_position(),  # Returns [x, y, z, rx, ry, rz] array
                            'gripper': gripper_pos,
                            'wait_time': wait_time
                        }
                        waypoint_set['waypoints'].append(waypoint_data)
                        controller.save_waypoint_set(waypoint_set, filename)
                        print(f" Added waypoint '{waypoint_name}' to {filename}")
                        if gripper_pos is not None:
                            print(f"    Gripper position: {gripper_pos}")
                        if wait_time > 0:
                            print(f"    Wait time: {wait_time}s")
                else:
                    print(" Unknown command. Type 'quit' to exit.")
                    
            except KeyboardInterrupt:
                break
            except EOFError:
                break
                
    except Exception as e:
        print(f" Error: {e}")
    finally:
        try:
            controller.destroy_node()
        except:
            pass
        rclpy.shutdown()
        print("\n Waypoint controller stopped.")


if __name__ == '__main__':
    main()
